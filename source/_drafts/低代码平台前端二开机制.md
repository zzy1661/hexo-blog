低代码平台前端二开机制，大致有两种：

1. 平台直接提供整个页面的代码，即出码
2. 平台提供视图组件，组件约定二开机制，即配置扩展

## 出码方案的优缺点

1. 优点：自由度高，可完全突破平台内置的样式/布局/交互约束，可补充各种自定义逻辑
2. 缺点：产出的代码复杂,开发/维护成本高；
   一旦出码，再使用平台的配置比较困难。基本上出码后就脱离了平台的配置，平台上视图新增了一个控件，得进行复杂的比对，才能将部分新增内容插入到本地代码中，类似 git 的冲突合并。

## 配置扩展方案

平台提供一个完整的组件，比如列表视图就提供一个 Table 组件，表单视图提供一个 Form 组件。
默认情况该组件会拉取平台配置进行渲染。
二开点全部基于配置 schema 进行开发，比如配置 schema 中，对表格类和表单项的描述如下：

```
{
    "columns":[{
        "key":"status",
        "title":"状态",
        "type":"enum",
        "enumOptions":[
            {"t":"正常","v":"1"},
            {"t":"异常","v":"0"}
        ]
    }],
       "formItems":[{
        "key":"startDate",
        "title":"开始日期",
        "type":"date",
        "required":true,
        "editWidget":"dataPicker"
    }]
}
```

1. 对表格的"状态"列自定义渲染内容，则对组件传入扩展配置：

```
{
    "customSetting":{
        "columns":[{
            key:"status",
            render:CustomStatusRender
        }],

    }
}
```

2. 对表单项"开始日期"自定义编辑控件，则可对组件传入扩展配置

```
{
    "customSetting":{
        "formItems":[{
            key:"startDate",
            editWidget:CustomDatePicker
        }]
    }
}
```
组件对开发者是个黑盒，增删改查所有逻辑都在黑盒内运行，开发者只能根据组件约定的方式，对有限的配置进行二开。
比如要调整布局/交互，但组件本身没有提供这方面能力，则无法实现。

这种设计方案的优点是二开成本低，并且可以继续使用平台配置。
在该方案下，组件应当遵循以下原则：
1. 尽可能多开放内部逻辑，比如点击打开详情，出发查询刷新，勾选，表单校验保存提交等
2. 尽可能多开放内部数据，比如表格/表单当前数据、动态枚举/关系数据，当前配置项
3. 尽可能多开放配置项
4. 尽可能多的暴露内部事件，比如查询前后、修改前后等

基于以上原则，可以推导出如下设计：
1. 组件应进行ui和数据分层，ui和数据层以action或事件交互，对外暴露action
2. 组件应设计多种hooks，before类hooks应支持阻塞/取消
3. 组件应将配置进行颗粒度划分，配置作为全局静态数据，与状态分离，而状态也应以全局和局部进行划分
4. 扩展配置应区分静态扩展配置（多次渲染只会处理一次）和动态扩展配置（每次渲染都会处理）
比如是布局配置，则应每次渲染都需要合并布局配置，开发者可能会因不同的数据而需要不同的布局
如果是渲染控件配置，则在组件初始化后，将该控件合并到配置中后，多次渲染均不更新该配置，如果开发者需要在某些条件下显示A控件，其他情况显示B控件，这种逻辑在一个组件内实现，该组件可以通过props获取当前配置、数据，然后再进行判断渲染A还是B